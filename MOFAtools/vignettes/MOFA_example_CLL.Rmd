---
title: " Vignette illustrating the use of MOFA on the CLL data"
author: "Britta Velten"
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document:
    toc: true
vignette: >
  %\VignetteIndexEntry{Example_CLL}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r}
devtools::load_all("/Users/bvelten/Documents/MOFA/MOFApackage/scGFA/MOFAtools/")
library(MultiAssayExperiment)
```

Get CLL data used for illustration in this vignette:
```{r}
data("CLL_views")
covariates <- data.frame(sex= CLL_views[["covariates"]][1,], 
                        diagnosis = CLL_views[["covariates"]][2,])

# use omic data (and remove patients from experiments in which they are completly unobserved)
CLL_omics <-  lapply( CLL_views[c("lincRNA","meth","miRNA","mRNA","mut","viab")], 
                      function(mat) mat[,apply(mat,2, function(p) !all(is.na(p)))]) 
                    
#create multi-Assay Experiment
mae_CLL <- MultiAssayExperiment(experiments = CLL_omics, 
                       pData = covariates)
```


# Step 1: Initialize MOFA object from your input data
For each data modality the input can be an SummarizedExperiment or a list of matrices where features are rows and samples are columns.
initilaizeMOFA fills in the TrainData slot of the MOFA object.

Starting from a multi-assay experiment. 'minViews' determines the number of views a sample must have been observed to be included into the MOFA object.
```{r}
object <- createMOFAobject(mae_CLL, minViews = 1)
```

Altenative: Starting from a list of data matrices, MutliAssayExperiment is constructed interally and used for InputData slot
```{r}
# create a MOFA object starting from a list of experiment data and optional covariates on the samples
# object <- createMOFAobjectFromList(ExpList = CLL_omics,
#                          pData = covariates)
```


# Step 2: Fit the MOFA model to get latent factors and associated weights

## Python - based
Generate text files used as input for the Pyhton code, run Python and read model back in
```{r}
# Define Model options as CLL views are not all gaussian (otherwise prepareMOFA can be used without ModelOptions argument to obtain defaults)
ModelOptions <- getDefaultModelOpts(object)
ModelOptions$likelihood[viewNames(object)=="mut"] <- "bernoulli"

# The following function creates the txt files which can be directly used as input for Python-MOFA and sets the model and training options
# Alternatively this can all directly be done using Python
outFile <- file.path(dir, "MOFAout.hdf5")
object_untrained <- prepareMOFA(object, dir = "~/Documents/MOFA/CLL_MOFA_data/testPipeline", 
                                ModelOptions = ModelOptions, TrainOptions = NULL,
                                outFile=outFile, k=10, MOFAdir = "/Users/bvelten/Documents/MOFApackage/scGFA/scGFA/run")
# for default options just use: object <- prepareMOFA(object, dir = "~/Documents/MOFA/CLL_MOFA_data/testPipeline")

# ... run python code, need a seperate documentation for this

# load fitted model from the output object created in Python
object_trained <- loadModel(outFile, object_untrained)

#print object
object_trained
```

## R - based
Ideally this should be replace by an interal function (C++ based?)
```{r}
# NOT YET AVAILABLE
# object <- runMOFA(object)
```


# Step 3: Label Factors
Use feature sets (e.g. gene sets) to test for enrichment and show top weights -> arrive at lables for each factor
```{r}
setFactornames(object, names)
```


# Show variance explained
```{r}
calculateVarianceExplained(object)
```

# Show LF scatterplots
```{r}
scatterPairs(object)
sctterPlot(object, facotr)
```

# Show top weights per view and factor
```{r}
showWeightHeatmap(object, "view")
showWeights(object, "view", factor, ntop, ntail, manual)

```

=======
# Plot the observed values of relevant features

## Heatmap 
```{r}
showDataHeatmap(model, view, factor, nfeatures=50)
```

## Scatterplot
The X axis is the latent variable and the Y axis is the observed value of the feature
```{r}
showDataScatter(model, view, factor, nfeatures=50, colour_by=NULL, shape_by=NULL)
```

# Feature set enrichment analysis

The characterisation of factors usually requires the inspection of the corresponding weights to identify features with strong influence. However, looking at single features can be challenging and often the combination of signal from functionally related sets of features (i.e. gene ontologies) is required.
Here we implemented a feature set enrichment analysis method (FeatureSetEnrichmentAnalysis) derived from the PCGSE package (REF).
The input of these function is a MOFA trained model (MOFAmodel), the factors for which to perform feature set enrichment (character vector), the feature sets (matrix) and a set of options regarding how the analysis should be performed. For more information see ...

Here we are going to perform feature set enrichment analysis on the mRNA view.

## Load feature sets
The input format for feature sets has to be a binary matrix where the rows represent feature sets and the columns are features where a value of 1 indicates that the feature belongs to the corresponding feature set.
```{r}

```

The next step is to define the options for the analysis.
Here we are going to use the absolute value of the weight (or loading) as feature statistic, the mean difference between the features in the gene set and the features outside the gene set as a feature set statistic and the correlation-adjusted parametric statistical test.

## Perform Feature Set Enrichment Analysis
```{r}
p.values <- FeatureSetEnrichmentAnalysis(
  model,
  view = "mRNA", 
  factors = "all", 
  feature.sets = reactome,
  local.statistic = "loading",
  transformation = "abs.value",
  global.statistic = "mean.diff",
  statistical.test = "cor.adj.parametric",
  nperm=NA, 
  min.size=10,
  cores=1
)
```

## Correct for multiple testing
```{r}
p.values_adj <- apply(p.values, 2,function(lfw) p.adjust(lfw, method = "BH"))
```

## Visualise the results

### All factors 
```{r}
Heatmap_FeatureSetEnrichmentAnalysis(gsea.out.adj_reactome, threshold=0.1)
```

### Individual factors
```{r}
LinePlot_FeatureSetEnrichmentAnalysis(gsea.out.adj_reactome, view, factor, threshold=0.1, max.pathways=25)
```

# Impute Missing
```{r}
imputeMissing(object)
```


# Cluster samples
```{r}
clusterMOFA(object, factors)
```

