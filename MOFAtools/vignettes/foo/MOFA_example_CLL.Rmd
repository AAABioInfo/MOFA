---
title: " Vignette illustrating the use of MOFA on the CLL data"
author: "Britta Velten and Ricard Argelaguet"
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document:
    toc: true
vignette: >
  %\VignetteIndexEntry{Example_CLL}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r}
# devtools::load_all("/Users/bvelten/Documents/MOFA/MOFApackage/scGFA/MOFAtools/")
# devtools::load_all("/Users/ricard/mofa/MOFAtools")
library(MultiAssayExperiment)
library(MOFAtools)
# %<>%, we should not use it or require the package...
# library(magrittr)
```

# Step 1: Initialize MOFA object

## Load data and create MOFA object
There are two ways to load the data into MOFA: 
(1) A MultiAssayExperiment object.
(2) A list of matrices where features are rows and samples are columns: MutliAssayExperiment is constructed internally
The input data is stored in the InputData slot of the MOFA object.
```{r}
data("CLL_views")

# Remove patients from experiments in which they are completly unobserved
CLL_omics <-  lapply( CLL_views[c("lincRNA","meth","miRNA","mRNA","mut","viab")], 
                      function(mat) mat[,apply(mat,2, function(p) !all(is.na(p)))]) 

# Define pData
covariates <- data.frame(
  row.names = colnames(CLL_views[["covariates"]]),
  sex = CLL_views[["covariates"]][1,], 
  diagnosis = CLL_views[["covariates"]][2,],
  IGHV = CLL_views[["mut"]]["IGHV",],
  trisomy12 = CLL_views[["mut"]]["trisomy12",]
)

# Define sampleMap (in this case is just identity, we don't need to do this)
# mRNAmap <- data.frame(primary=colnames(CLL_views[["mRNA"]]), assay=colnames(CLL_views[["mRNA"]]), stringsAsFactors = FALSE)
# miRNAmap <- data.frame(primary=colnames(CLL_views[["miRNA"]]), assay=colnames(CLL_views[["miRNA"]]), stringsAsFactors = FALSE)
# lincRNAmap <- data.frame(primary=colnames(CLL_views[["lincRNA"]]), assay=colnames(CLL_views[["lincRNA"]]), stringsAsFactors = FALSE)
# methmap <- data.frame(primary=colnames(CLL_views[["meth"]]), assay=colnames(CLL_views[["meth"]]), stringsAsFactors = FALSE)
# mutmap <- data.frame(primary=colnames(CLL_views[["mut"]]), assay=colnames(CLL_views[["mut"]]), stringsAsFactors = FALSE)
# viabmap <- data.frame(primary=colnames(CLL_views[["viab"]]), assay=colnames(CLL_views[["viab"]]), stringsAsFactors = FALSE)
# listmap <- list(mRNAmap, miRNAmap, lincRNAmap, methmap, mutmap, viabmap)
# names(listmap) <- c("mRNA", "miRNA", "lincRNA", "Methylation","Mutations","Drugs")
# dfmap <- listToMap(listmap)

# Create MultiAssayExperiment object
# mae_CLL <- MultiAssayExperiment(experiments = CLL_omics, pData = covariates)
mae_CLL <- MultiAssayExperiment(experiments = CLL_omics, colData = covariates)
```

### Create MOFA object using MultiAssayExperiment
```{r}
object <- createMOFAobject(mae_CLL)
```

### Create MOFA object using list of matrices
```{r}
# object <- createMOFAobjectFromList(ExpList = CLL_omics, pData = covariates)
```

# Step 2: Fit the MOFA model

## Define options

### Define I/O options
Important:
- mofaDir: directory of the MOFA package
- outFile: Output file for the model
```{r}
DirOptions <- list(
  "mofaDir" = "/Users/ricard/mofa/MOFA",
  "outFile" = "/Users/ricard/test.hdf5"
)

# DirOptions <- list(
#   "mofaDir" = "/users/bvelten/Documents/MOFA/MOFApackage/scGFA/MOFA",
#   "outFile" = "/users/bvelten/Documents/MOFA/CLL_MOFA_data/testPipeline/test.hdf5"
# )
```

### Define model options
The user can look in the documentation and the function getDefaultModelOpts for the different options, but the default ones work fine. The most important thing the user has to define is the initial number of latent variables and the likelihood type (if not provided, the model tries to guess it from the data) 
```{r}
ModelOptions <- getDefaultModelOpts(object)
ModelOptions$initialK <- 10
```

### Define training options
The user can look in the documentation and the function getDefaultTrainOpts for the different options, but the default ones work fine. The most important thing the user has to define is the maximum number of iterations and whether/how to drop inactive latent factors while training.
```{r}
TrainOptions <- getDefaultTrainOpts()
TrainOptions$maxiter <- 10
TrainOptions$drop_by_norm <- 0.00
TrainOptions$drop_by_r2 <- 0.00
```

## Prepare MOFA
Internally, prepareMOFA performs a set of sanity checks, fills the TrainOpts and ModelOpts slots of the MOFAmodel object and it also creates a set of temporary files with the input matrices that will be loaded by the Python core implementation
```{r}
object <- prepareMOFA(object, 
                      DirOptions = DirOptions,
                      ModelOptions = ModelOptions,
                      TrainOptions = TrainOptions
)
```

## Run MOFA
This step can take some time and it decouples from the R package, it is recommended to run it from the Python-based module
```{r}
object <- runMOFA(object, DirOptions)
# object <- readRDS(DirOptions$outFile)

#for demonstration purposes use already fitted object
# object <- loadModel("/Users/bvelten/Documents/MOFA/CLL_MOFA_data/out/test_final/common_small_noXY_alldrugs_mean2.hdf5")
object <- loadModel("/Users/ricard/data/CLL/out/test_final/common_small_noXY_alldrugs_mean2.hdf5")
# data <- TrainData(object)
```

# Step 3: Analyse a trained MOFA model

## Show the variance explained for each factor in each view
```{r}
r2 <- calculateVarianceExplained(object)
r2 <- calculateVarianceExplained(object, showtotalR2 = T, showVarComp = F)
```

## Inspect latent facotrs
Scatterplots of pairs of latent variables and beeswarm/histogram fo single LFs
```{r}
ighv <- as.factor(TrainData(object)[["mut"]]["IGHV",])
scatterPairs(object, factors = c("4","8"), showMissing = F, colour_by = ighv, colour_name = "IGHV")
beeswarmPlot(object, factor="4", color = ighv, color_name = "IGHV")
# histPlot(object, "4", groups = as.factor(data$mut["IGHV",]), name_colour ="IGHV" )
```

## Characterisation of specific latent factors by inspection of the weights


### Show weights and identify most relevant features
There are two main functions to display the weights, a heatmap and a line plot
```{r}
showWeightHeatmap(object, view="mRNA", features="all", factors="all", show_rownames=F, cluster_cols=F)

top <- names(tail(sort(abs(getExpectations(object,"SW","E")[["mRNA"]][,2])), n=10))
showWeightHeatmap(object, view="mRNA", features=top, factors=c("2","3"), 
                  main="Weight matrix for a subset of features and factors", 
                  show_rownames=T, cluster_cols=F, cluster_rows=F)
```

THIS PLOT IS A BIT UGGLY, WE NEED SOME MODIFICATION...
```{r}
showWeights(object, "mut", 4)
```


### Show original data for the genes with top weights
There is a function to inspect the original data focusing on the features with top weights in a particular factor
```{r}
showDataHeatmap(object, view="mRNA", factor="2", nfeatures=50)
# showDataScatter(object, "mRNA", 4)
# The X axis is the latent variable and the Y axis is the observed value of the feature
# showDataScatter(object, view, factor, nfeatures=50, colour_by=NULL, shape_by=NULL)
```


### Feature set enrichment analysis
The characterisation of factors usually requires the inspection of the corresponding weights. However, looking at the loadings of single features can be challenging, and often the combination of signal from functionally related sets of features (i.e. gene ontologies) is required.
Here we implemented a feature set enrichment analysis method (FeatureSetEnrichmentAnalysis) derived from the PCGSE package (REF).
The input of these function is a MOFA trained model (MOFAmodel), the factors for which to perform feature set enrichment (a character vector), the feature sets (a binary matrix) and a set of options regarding how the analysis should be performed. For more information see ...

Here we are going to perform feature set enrichment analysis on the mRNA view with the following options: absolute value of the weight (or loading) as feature statistic, the mean difference between the features in the gene set and the features outside the gene set as a feature set statistic and the correlation-adjusted parametric statistical test.
```{r}
# The input format for feature sets has to be a binary matrix where the rows represent feature sets and the columns are features where a value of 1 indicates that the feature belongs to the corresponding feature set.

# Load reactome annotations
reactome <- readRDS("/Users/ricard/data/reactome/v59/homo_sapiens/out/human_reactome.rds")

# Rename pathways
tmp <- read.table("/Users/ricard/data/reactome/v59/homo_sapiens/AllPathways.txt", header=F, quote="", sep="\t", stringsAsFactors=F)[,c(1,2)]
reactome_meta <- tmp[,2]; names(reactome_meta) <- tmp[,1]
rownames(reactome) <- stringr::str_replace_all(rownames(reactome), reactome_meta)

# Load reactome annotations + information on pathways
# reactome<-readRDS("~/Documents/MOFA/CLL_MOFA_data/GO/reactome/human_reactome_binary_matrix.rds")
# ReactomePathwayInfo<-readLines("~/Documents/MOFA/CLL_MOFA_data/GO/reactome/ReactomePathwaysMeta.txt")
# ReactomePathwayInfo<-do.call(rbind,strsplit(ReactomePathwayInfo, "\t"))
# colnames(ReactomePathwayInfo)<-c("id", "description", "species")
# ReactomePathwayInfo<-as.data.frame(ReactomePathwayInfo)
# ReactomePathwayInfo<-ReactomePathwayInfo[ReactomePathwayInfo$species=="Homo sapiens",]
# rownames(reactome) <- ReactomePathwayInfo$description[match(rownames(reactome), ReactomePathwayInfo$id)]

# Run Feature Set Enrichment Analysis (basic with default options)
# FSE.out <- FeatureSetEnrichmentAnalysis(object, view = "mRNA", feature.sets = reactome)

# Run Feature Set Enrichment Analysis (advanced)
FSE.out <- FeatureSetEnrichmentAnalysis(
  object,
  view = "mRNA",
  factors = "all",
  feature.sets = reactome,
  local.statistic = "loading",
  transformation = "abs.value",
  global.statistic = "mean.diff",
  # statistical.test = "permutation",
  statistical.test = "cor.adj.parametric",
  nperm=5,
  min.size=10,
  cores=1, 
  alpha=0.05
)

# Extract p values
pval <- FSE.out$pval.adj

```

The next step is to visualise the results of the Gene Set Enrichment Analysis. There are two default plots:
(1) General Overview: Heatmap with the p.values, rows being pathways and columns being factors. 
```{r}
Heatmap_FeatureSetEnrichmentAnalysis(pval, threshold=0.10, log=T)
```

(2) Factor-specific:
```{r}
interestingFactors <- c("2")
for (factor in interestingFactors) {
  LinePlot_FeatureSetEnrichmentAnalysis(pval, factor, threshold=0.05, max.pathways=25)
}
```

## Imputation of missing observations
```{r}
object<-imputeMissing(object)
```


## Clustering of samples based on latent factors
```{r}

# Using all latent factors
h <- clusterSamples(object, "all", anno_df=NULL)

# Using only a subset of latent factors and include annotation data frame
# clusterSamples(object, "4", anno_df = data.frame(data$mut["IGHV",]))
h <- clusterSamples(object, factors=c("2","4"), anno_df = covariates[sampleNames(object),])
```
